shader_type spatial;

// Terrain shader with biome-based colors and slope detection
// Uses dynamic biome texture that follows the player for perfect alignment
// The texture is generated by GDScript using FastNoiseLite and updated as player moves

uniform int world_seed = 12345;

// Slope thresholds
uniform float slope_rock_start : hint_range(0.0, 1.0) = 0.6;
uniform float slope_rock_full : hint_range(0.0, 1.0) = 0.8;

// Dynamic biome texture system - follows the player
uniform sampler2D biome_texture : hint_default_black, filter_linear, repeat_disable;
uniform vec2 biome_texture_center = vec2(0.0, 0.0);  // World position of texture center
uniform float biome_texture_size = 512.0;  // World units covered by the texture

// ========== BIOME COLORS (Fantasy bright colors - matching Hamberg) ==========

// Valley biome - BRIGHT BLUE serene meadows
const vec3 VALLEY_GRASS = vec3(0.25, 0.55, 0.95);
const vec3 VALLEY_GRASS_DARK = vec3(0.15, 0.45, 0.85);
const vec3 VALLEY_ROCK = vec3(0.4, 0.42, 0.45);

// Dark Forest biome - DARK TEAL-GREEN bioluminescent
const vec3 FOREST_GRASS = vec3(0.05, 0.25, 0.15);
const vec3 FOREST_GRASS_DARK = vec3(0.02, 0.18, 0.10);
const vec3 FOREST_ROCK = vec3(0.15, 0.2, 0.18);

// Swamp biome - YELLOW-GREEN murky
const vec3 SWAMP_GRASS = vec3(0.6, 0.75, 0.3);
const vec3 SWAMP_GRASS_DARK = vec3(0.5, 0.65, 0.2);
const vec3 SWAMP_ROCK = vec3(0.25, 0.22, 0.18);

// Mountain biome - WHITE snow/ice
const vec3 MOUNTAIN_GRASS = vec3(0.95, 0.97, 1.0);
const vec3 MOUNTAIN_GRASS_DARK = vec3(0.85, 0.90, 0.95);
const vec3 MOUNTAIN_ROCK = vec3(0.6, 0.62, 0.68);

// Desert biome - BRIGHT YELLOW sandy
const vec3 DESERT_SAND = vec3(0.95, 0.85, 0.35);
const vec3 DESERT_SAND_DARK = vec3(0.85, 0.75, 0.25);
const vec3 DESERT_ROCK = vec3(0.7, 0.58, 0.4);

// Wizardland biome - BRIGHT MAGENTA magical
const vec3 WIZARD_GRASS = vec3(0.9, 0.3, 1.0);
const vec3 WIZARD_GRASS_DARK = vec3(0.75, 0.2, 0.85);
const vec3 WIZARD_ROCK = vec3(0.55, 0.35, 0.65);

// Hell biome - BRIGHT RED hellfire
const vec3 HELL_GROUND = vec3(0.9, 0.2, 0.1);
const vec3 HELL_GROUND_DARK = vec3(0.7, 0.1, 0.05);
const vec3 HELL_ROCK = vec3(0.3, 0.12, 0.08);

// Simple hash for color variation
float hash(vec2 p) {
	return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// 2D noise for color variation
float noise2D(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);
	f = f * f * (3.0 - 2.0 * f);

	float a = hash(i);
	float b = hash(i + vec2(1.0, 0.0));
	float c = hash(i + vec2(0.0, 1.0));
	float d = hash(i + vec2(1.0, 1.0));

	return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

// Get grass color for biome index
vec3 get_biome_grass_color(int biome) {
	if (biome == 0) return VALLEY_GRASS;
	else if (biome == 1) return FOREST_GRASS;
	else if (biome == 2) return SWAMP_GRASS;
	else if (biome == 3) return MOUNTAIN_GRASS;
	else if (biome == 4) return DESERT_SAND;
	else if (biome == 5) return WIZARD_GRASS;
	else if (biome == 6) return HELL_GROUND;
	return VALLEY_GRASS;
}

// Get grass dark color for biome index
vec3 get_biome_grass_dark_color(int biome) {
	if (biome == 0) return VALLEY_GRASS_DARK;
	else if (biome == 1) return FOREST_GRASS_DARK;
	else if (biome == 2) return SWAMP_GRASS_DARK;
	else if (biome == 3) return MOUNTAIN_GRASS_DARK;
	else if (biome == 4) return DESERT_SAND_DARK;
	else if (biome == 5) return WIZARD_GRASS_DARK;
	else if (biome == 6) return HELL_GROUND_DARK;
	return VALLEY_GRASS_DARK;
}

// Get rock color for biome index
vec3 get_biome_rock_color(int biome) {
	if (biome == 0) return VALLEY_ROCK;
	else if (biome == 1) return FOREST_ROCK;
	else if (biome == 2) return SWAMP_ROCK;
	else if (biome == 3) return MOUNTAIN_ROCK;
	else if (biome == 4) return DESERT_ROCK;
	else if (biome == 5) return WIZARD_ROCK;
	else if (biome == 6) return HELL_ROCK;
	return VALLEY_ROCK;
}

// Biome blend info structure
struct BiomeBlendInfo {
	int primary_biome;
	int secondary_biome;
	float blend_weight;
	bool valid;
};

// Sample biome blend info from dynamic texture (follows player, generated by GDScript)
BiomeBlendInfo sample_biome_blend_from_texture(vec2 xz_pos) {
	BiomeBlendInfo info;
	info.valid = false;
	info.primary_biome = 0;
	info.secondary_biome = 0;
	info.blend_weight = 0.0;

	// Calculate UV coordinates relative to texture center
	vec2 offset = xz_pos - biome_texture_center;
	vec2 uv = (offset / biome_texture_size) + 0.5;  // 0-1 range, centered

	// Clamp to texture bounds - outside the texture, fall back to default
	if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
		return info;  // Signal to use fallback
	}

	// Sample texture - R=primary biome, G=secondary biome, B=blend weight
	vec3 tex_data = texture(biome_texture, uv).rgb;
	info.primary_biome = int(tex_data.r * 7.0 + 0.5);
	info.secondary_biome = int(tex_data.g * 7.0 + 0.5);
	info.blend_weight = tex_data.b;
	info.valid = true;

	return info;
}

void fragment() {
	// World position for noise
	vec3 world_pos = (INV_VIEW_MATRIX * vec4(VERTEX, 1.0)).xyz;
	vec2 world_xz = world_pos.xz;

	// Get slope from normal (0 = flat, 1 = vertical)
	float slope = 1.0 - abs(NORMAL.y);

	// Try to get biome blend info from dynamic texture (perfect alignment)
	BiomeBlendInfo blend_info = sample_biome_blend_from_texture(world_xz);

	vec3 grass_color;
	vec3 grass_dark_color;
	vec3 rock_color;

	if (blend_info.valid) {
		// Get colors for primary biome
		vec3 primary_grass = get_biome_grass_color(blend_info.primary_biome);
		vec3 primary_grass_dark = get_biome_grass_dark_color(blend_info.primary_biome);
		vec3 primary_rock = get_biome_rock_color(blend_info.primary_biome);

		// Blend with secondary biome if weight > 0
		if (blend_info.blend_weight > 0.001) {
			vec3 secondary_grass = get_biome_grass_color(blend_info.secondary_biome);
			vec3 secondary_grass_dark = get_biome_grass_dark_color(blend_info.secondary_biome);
			vec3 secondary_rock = get_biome_rock_color(blend_info.secondary_biome);

			grass_color = mix(primary_grass, secondary_grass, blend_info.blend_weight);
			grass_dark_color = mix(primary_grass_dark, secondary_grass_dark, blend_info.blend_weight);
			rock_color = mix(primary_rock, secondary_rock, blend_info.blend_weight);
		} else {
			grass_color = primary_grass;
			grass_dark_color = primary_grass_dark;
			rock_color = primary_rock;
		}
	} else {
		// Fallback to valley if outside texture bounds
		grass_color = VALLEY_GRASS;
		grass_dark_color = VALLEY_GRASS_DARK;
		rock_color = VALLEY_ROCK;
	}

	// Add noise-based variation to grass
	float grass_noise = noise2D(world_xz * 0.1);
	float detail_noise = noise2D(world_xz * 0.5);

	// Blend between grass variations
	vec3 grass_final = mix(grass_dark_color, grass_color, grass_noise);
	grass_final = mix(grass_final, grass_color * 1.1, detail_noise * 0.3);

	// Add small-scale detail
	float micro_noise = noise2D(world_xz * 2.0);
	grass_final *= 0.9 + micro_noise * 0.2;

	// Rock variation
	float rock_noise = noise2D(world_xz * 0.3);
	vec3 rock_final = rock_color * (0.85 + rock_noise * 0.3);

	// Blend based on slope
	float rock_blend = smoothstep(slope_rock_start, slope_rock_full, slope);

	// Final color
	vec3 final_color = mix(grass_final, rock_final, rock_blend);

	// Slightly darken lower areas (fake ambient occlusion)
	float height_factor = clamp(world_pos.y / 50.0, 0.0, 1.0);
	final_color *= 0.85 + height_factor * 0.15;

	ALBEDO = final_color;

	// Roughness based on surface type
	ROUGHNESS = mix(0.85, 0.95, rock_blend);

	// Subtle specular for wet swamp
	if (blend_info.valid && blend_info.primary_biome == 2) {
		ROUGHNESS = mix(0.7, 0.9, rock_blend);
	}
}
